// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

//
// ================= Enums =================
//

enum Role {
  STUDENT
  TUTOR
  ADMIN
}

enum UserStatus {
  PENDING
  ACTIVE
  SUSPENDED
}

enum Gender {
  MALE
  FEMALE
  OTHER
}

enum EducationLevel {
  PRIMARY
  MIDDLE
  MATRIC_SECONDARY
  INTERMEDIATE
  UNDERGRADUATE
  GRADUATE
  POSTGRADUATE
  OTHER
}

enum RequestStatus {
  DRAFT
  OPEN
  APPROVED
  IN_PROGRESS
  COMPLETED
  REJECTED
  CANCELLED
}

enum RequestType {
  HIRE_TUTOR
  HIRE_QURAN
}

enum Mode {
  ONLINE
  OFFLINE
  HYBRID
}

enum ApplicationStatus {
  SUBMITTED
  SHORTLISTED
  FORWARDED_TO_STUDENT
  ACCEPTED_BY_STUDENT
  DECLINED_BY_STUDENT
}

enum AssignmentStatus {
  PENDING_TUTOR_ACCEPT
  ACCEPTED
  REJECTED
}

//
// ================= Core Models =================
//

model User {
  id             String     @id @default(cuid())
  name           String?
  email          String     @unique
  hashedPassword String
  role           Role       @default(STUDENT)
  status         UserStatus @default(PENDING)
  image          String?
  emailVerified  DateTime?
  createdAt      DateTime   @default(now())
  updatedAt      DateTime   @updatedAt

  // relations
  studentProfile   StudentProfile?
  tutorProfile     TutorProfile?
  requests         Request[]                @relation("RequestCreatedBy")
  applications     Application[]            @relation("UserApplications")
  assignments      Assignment[]             @relation("UserAssignments")
  notifications    Notification[]
  emailTokens      EmailToken[]
  emailVerifTokens EmailVerificationToken[]
}

//
// Detailed student profile used on student dashboard
//
model StudentProfile {
  userId String @unique
  user   User   @relation(fields: [userId], references: [id])

  name           String?
  phone          String?
  phoneAlt       String?
  educationLevel EducationLevel?
  gender         Gender?
  institute      String?
  addressLine    String?
  location       String?
  countryCode    String?
  stateCode      String?
  cityName       String?
  zip            String?
  cnicPassport   String?
  notes          String?
  image          String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

//
// Minimal tutor profile (extend as needed)
//
model TutorProfile {
  userId String @unique
  user   User   @relation(fields: [userId], references: [id])

  bio      String?
  subjects String? // comma-separated or JSON if you prefer
  rating   Float?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

//
// Student request (kept compatible with your routes)
//
model Request {
  id          String @id @default(cuid())
  createdById String
  createdBy   User   @relation("RequestCreatedBy", fields: [createdById], references: [id])

  type   RequestType
  status RequestStatus @default(OPEN)

  // address/contact for the specific request
  contactName    String?
  contactPhone   String?
  reqCountryCode String?
  reqStateCode   String?
  reqCityName    String?
  reqAddressLine String?
  reqZip         String?

  // scheduling/basic preferences (optional; keep if you need)
  mode Mode?

  // relations
  applications Application[]
  assignments  Assignment[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status, type])
  @@index([createdById, status])
}

model Application {
  id        String @id @default(cuid())
  requestId String
  tutorId   String

  request Request @relation(fields: [requestId], references: [id])
  tutor   User    @relation("UserApplications", fields: [tutorId], references: [id])

  coverNote   String?
  proposedFee Int?
  schedule    String?
  status      ApplicationStatus @default(SUBMITTED)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([requestId])
  @@index([tutorId])
}

model Assignment {
  id        String @id @default(cuid())
  requestId String
  tutorId   String

  request Request @relation(fields: [requestId], references: [id])
  tutor   User    @relation("UserAssignments", fields: [tutorId], references: [id])

  status AssignmentStatus @default(PENDING_TUTOR_ACCEPT)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([requestId])
  @@index([tutorId])
}

//
// Optional: public courses (safe to keep)
//
model Course {
  id        String   @id @default(cuid())
  title     String
  slug      String   @unique
  summary   String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

//
// Email verification tokens (dedicated)
//
model EmailVerificationToken {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  tokenHash String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([expiresAt])
}

//
// Generic email tokens (e.g., password reset, magic links)
//
model EmailToken {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  purpose   String // "verify" | "reset" | "login" etc.
  tokenHash String   @unique
  expiresAt DateTime
  consumed  Boolean  @default(false)
  createdAt DateTime @default(now())

  @@index([userId, purpose])
  @@index([expiresAt, consumed])
}

//
// Login throttle row per (email, role)
//
model LoginThrottle {
  id            String    @id @default(cuid())
  email         String
  role          Role
  count         Int       @default(0)
  lastAttemptAt DateTime?
  lockedUntil   DateTime?

  @@unique([email, role])
  @@index([lockedUntil])
}

//
// OTP challenges (NO 'attempts' / NO 'payload')
// Used by /api/auth/otp/start and /verify
//
model OtpChallenge {
  id        String   @id @default(cuid())
  email     String
  reason    String // "login" | "register"
  codeHash  String
  expiresAt DateTime
  used      Boolean  @default(false)
  createdAt DateTime @default(now())

  @@index([email, reason, createdAt])
  @@index([email, reason, used, expiresAt])
}

//
// Notifications
//
model Notification {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id])

  title String
  body  String?
  read  Boolean @default(false)

  createdAt DateTime @default(now())

  @@index([userId, read, createdAt])
}
